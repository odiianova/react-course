'use client';
import { b as block$1, M as MapHas$, a as MapSet$, m as mount$, p as patch, c as arrayPatch$, d as mapArray, e as arrayMount$, f as MapGet$, g as mount } from '../shared/million.2a355d8b.mjs';
export { r as removeComments } from '../shared/million.2a355d8b.mjs';
import { isValidElement, Fragment, createElement, useRef, useCallback, useMemo, useState, useEffect, memo } from 'react';
import { a as REGISTRY, R as RENDER_SCOPE, S as SVG_RENDER_SCOPE, E as Effect } from '../shared/million.5e1fca0a.mjs';
import { createPortal } from 'react-dom';

const processProps = (props, ref, portals) => {
  const processedProps = { ref };
  let currentIndex = 0;
  for (const key in props) {
    const value = props[key];
    if (isValidElement(value) || Array.isArray(value) && value.length && isValidElement(value[0])) {
      processedProps[key] = renderReactScope(
        value,
        false,
        portals,
        currentIndex++
      );
      continue;
    }
    processedProps[key] = props[key];
  }
  return processedProps;
};
const wrap = (vnode) => {
  return createElement(RENDER_SCOPE, { suppressHydrationWarning: true }, vnode);
};
const renderReactScope = (vnode, unstable, portals, currentIndex) => {
  const el = portals?.[currentIndex]?.current;
  const isBlock = isValidElement(vnode) && typeof vnode.type === "function" && "_c" in vnode.type;
  const isCallable = isBlock && vnode.type._c;
  if (typeof window === "undefined") {
    if (isBlock) {
      if (isCallable) {
        return vnode;
      }
      return wrap(wrap(vnode));
    }
    return wrap(vnode);
  }
  if (isCallable) {
    const puppetComponent = vnode.type(vnode.props);
    if (REGISTRY.has(puppetComponent.type)) {
      const puppetBlock = REGISTRY.get(puppetComponent.type);
      if (typeof puppetBlock === "function") {
        return puppetBlock(puppetComponent.props);
      }
    }
  }
  const current = el ?? document.createElement(RENDER_SCOPE);
  const reactPortal = createPortal(vnode, current);
  const millionPortal = {
    foreign: true,
    current,
    portal: reactPortal,
    unstable
  };
  if (portals) {
    portals[currentIndex] = millionPortal;
  }
  return millionPortal;
};
const unwrap = (vnode) => {
  if (typeof vnode !== "object" || vnode === null || !("type" in vnode)) {
    if (typeof vnode === "number") {
      return String(vnode);
    }
    return vnode;
  }
  let type = vnode.type;
  if (typeof type === "function") {
    return unwrap(type(vnode.props ?? {}));
  }
  if (typeof type === "object" && "$" in type)
    return type;
  const props = { ...vnode.props };
  if ("css" in props && "__EMOTION_TYPE_PLEASE_DO_NOT_USE__" in props) {
    props.style = props.css.styles;
    type = props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;
    delete props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;
    delete props.css;
  }
  const children = vnode.props?.children;
  if (children !== void 0 && children !== null) {
    props.children = flatten(vnode.props.children).map(
      (child) => unwrap(child)
    );
  }
  return {
    type,
    // lets pretend no function go through
    props
  };
};
const flatten = (rawChildren) => {
  if (rawChildren === void 0 || rawChildren === null)
    return [];
  if (typeof rawChildren === "object" && "type" in rawChildren && rawChildren.type === Fragment) {
    return flatten(rawChildren.props.children);
  }
  if (!Array.isArray(rawChildren) || typeof rawChildren === "object" && "$" in rawChildren) {
    return [rawChildren];
  }
  const flattenedChildren = rawChildren.flat(Infinity);
  const children = [];
  for (let i = 0, l = flattenedChildren.length; i < l; ++i) {
    children.push(...flatten(flattenedChildren[i]));
  }
  return children;
};

const block = (fn, options = {}) => {
  let blockTarget = options?.block;
  const defaultType = options?.svg ? SVG_RENDER_SCOPE : RENDER_SCOPE;
  if (fn) {
    blockTarget = block$1(
      fn,
      unwrap,
      options?.shouldUpdate,
      options?.svg
    );
  }
  const MillionBlock = (props, forwardedRef) => {
    const hmrTimestamp = props._hmr;
    const ref = useRef(null);
    const patch$1 = useRef(null);
    const portalRef = useRef([]);
    props = processProps(props, forwardedRef, portalRef.current);
    patch$1.current?.(props);
    const effect = useCallback(() => {
      if (!ref.current)
        return;
      const currentBlock = blockTarget(props, props.key);
      if (hmrTimestamp && ref.current.textContent) {
        ref.current.textContent = "";
      }
      if (patch$1.current === null || hmrTimestamp) {
        mount$.call(currentBlock, ref.current, null);
        patch$1.current = (props2) => {
          patch(
            currentBlock,
            blockTarget(
              props2,
              props2.key,
              options?.shouldUpdate
            )
          );
        };
      }
    }, []);
    const marker = useMemo(() => {
      return createElement(options?.as ?? defaultType, { ref });
    }, []);
    const childrenSize = portalRef.current.length;
    const children = new Array(childrenSize);
    for (let i = 0; i < childrenSize; ++i) {
      children[i] = portalRef.current[i]?.portal;
    }
    const vnode = createElement(Fragment, {}, marker, createElement(Effect, {
      effect,
      deps: hmrTimestamp ? [hmrTimestamp] : []
    }), children);
    return vnode;
  };
  if (!MapHas$.call(REGISTRY, MillionBlock)) {
    MapSet$.call(REGISTRY, MillionBlock, block);
  }
  if (options?.name) {
    if (fn) {
      fn.displayName = `Million(Render(${options.name}))`;
    }
    MillionBlock.displayName = `Million(Block(${options.name}))`;
  }
  return MillionBlock;
};

const MillionArray = ({
  each,
  children,
  memo: memo2,
  svg,
  as,
  ...rest
}) => {
  const ref = useRef(null);
  const [portals] = useState(() => ({
    current: Array(each.length)
  }));
  const fragmentRef = useRef(null);
  const cache = useRef({
    each: null,
    children: null,
    mounted: false
  });
  const [, setMountPortals] = useState(false);
  if (fragmentRef.current && (each !== cache.current.each || !memo2)) {
    const newChildren = createChildren(each, children, cache, portals, memo2);
    arrayPatch$.call(fragmentRef.current, mapArray(newChildren));
  }
  const defaultType = svg ? SVG_RENDER_SCOPE : RENDER_SCOPE;
  const MillionFor = createElement(
    Fragment,
    null,
    createElement(as ?? defaultType, { ...rest, ref }),
    ...portals.current.map((p) => p.portal)
  );
  useEffect(() => {
    if (!ref.current || fragmentRef.current)
      return;
    if (cache.current.mounted)
      return;
    const newChildren = createChildren(each, children, cache, portals, memo2);
    fragmentRef.current = mapArray(newChildren);
    if (!MapHas$.call(REGISTRY, MillionFor)) {
      MapSet$.call(REGISTRY, MillionFor, fragmentRef.current);
    }
    arrayMount$.call(fragmentRef.current, ref.current);
    cache.current.mounted = true;
    setMountPortals(true);
  }, [ref.current]);
  return MillionFor;
};
const typedMemo = memo;
const For = typedMemo(MillionArray);
const createChildren = (each, getComponent, cache, portals, memo2) => {
  const children = Array(each.length);
  const currentCache = cache.current;
  for (let i = 0, l = each.length; i < l; ++i) {
    if (memo2 && currentCache.each && currentCache.each[i] === each[i]) {
      children[i] = currentCache.children?.[i];
      continue;
    }
    const vnode = getComponent(each[i], i);
    if (MapHas$.call(REGISTRY, vnode.type)) {
      if (!currentCache.block) {
        currentCache.block = MapGet$.call(REGISTRY, vnode.type);
      }
      children[i] = currentCache.block(vnode.props, i);
      continue;
    }
    if (typeof vnode.type === "function" && "_c" in vnode.type) {
      const puppetComponent = vnode.type(vnode.props);
      if (MapHas$.call(REGISTRY, puppetComponent.type)) {
        const puppetBlock = MapGet$.call(REGISTRY, puppetComponent.type);
        if (typeof puppetBlock === "function") {
          children[i] = puppetBlock(puppetComponent.props);
          continue;
        }
      }
    }
    const block = block$1((props) => props?.scope);
    const currentBlock = (props, index) => {
      return block(
        {
          scope: renderReactScope(
            createElement(vnode.type, props),
            false,
            portals.current,
            index
          )
        },
        vnode.key ? String(vnode.key) : void 0
      );
    };
    MapSet$.call(REGISTRY, vnode.type, currentBlock);
    currentCache.block = currentBlock;
    children[i] = currentBlock(vnode.props, i);
  }
  currentCache.each = each;
  currentCache.children = children;
  return children;
};

function isEqual(a, b) {
  return a === b || a !== a && b !== b;
}
function shouldCompiledBlockUpdate(prev, next) {
  for (const key in prev) {
    if (!isEqual(prev[key], next[key])) {
      return true;
    }
  }
  return false;
}
function compiledBlock(render, { portals, ...options }) {
  const RenderBlock = block((props) => render(props), {
    ...options,
    name: `CompiledBlock(Inner(${options.name}))`,
    shouldUpdate: shouldCompiledBlockUpdate
  });
  const portalCount = portals?.length || 0;
  const Component = portals && portalCount > 0 ? (props) => {
    const [current] = useState(() => []);
    const derived = { ...props };
    for (let i = 0; i < portalCount; i++) {
      const index = portals[i];
      derived[index] = renderReactScope(
        derived[index],
        false,
        current,
        i
      );
    }
    const targets = [];
    for (let i = 0, len = current.length; i < len; i++) {
      targets[i] = current[i].portal;
    }
    return createElement(
      Fragment,
      {},
      createElement(RenderBlock, derived),
      targets
    );
  } : (props) => createElement(RenderBlock, props);
  if (options.name) {
    Component.displayName = `Million(CompiledBlock(Outer(${options.name})))`;
  }
  return Component;
}

const INTERNALS = {
  block: block$1,
  patch,
  mount
};
if (typeof window !== "undefined") {
  window.__MILLION_DATA__ = {
    version: "3.0.3"
  };
}

export { For, INTERNALS, REGISTRY, block, compiledBlock, renderReactScope, unwrap };
