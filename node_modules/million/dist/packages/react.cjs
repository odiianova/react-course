'use client';
'use strict';

const packages_million = require('../shared/million.b8801fca.cjs');
const react = require('react');
const constants = require('../shared/million.cdaea7d4.cjs');
const reactDom = require('react-dom');

const processProps = (props, ref, portals) => {
  const processedProps = { ref };
  let currentIndex = 0;
  for (const key in props) {
    const value = props[key];
    if (react.isValidElement(value) || Array.isArray(value) && value.length && react.isValidElement(value[0])) {
      processedProps[key] = renderReactScope(
        value,
        false,
        portals,
        currentIndex++
      );
      continue;
    }
    processedProps[key] = props[key];
  }
  return processedProps;
};
const wrap = (vnode) => {
  return react.createElement(constants.RENDER_SCOPE, { suppressHydrationWarning: true }, vnode);
};
const renderReactScope = (vnode, unstable, portals, currentIndex) => {
  const el = portals?.[currentIndex]?.current;
  const isBlock = react.isValidElement(vnode) && typeof vnode.type === "function" && "_c" in vnode.type;
  const isCallable = isBlock && vnode.type._c;
  if (typeof window === "undefined") {
    if (isBlock) {
      if (isCallable) {
        return vnode;
      }
      return wrap(wrap(vnode));
    }
    return wrap(vnode);
  }
  if (isCallable) {
    const puppetComponent = vnode.type(vnode.props);
    if (constants.REGISTRY.has(puppetComponent.type)) {
      const puppetBlock = constants.REGISTRY.get(puppetComponent.type);
      if (typeof puppetBlock === "function") {
        return puppetBlock(puppetComponent.props);
      }
    }
  }
  const current = el ?? document.createElement(constants.RENDER_SCOPE);
  const reactPortal = reactDom.createPortal(vnode, current);
  const millionPortal = {
    foreign: true,
    current,
    portal: reactPortal,
    unstable
  };
  if (portals) {
    portals[currentIndex] = millionPortal;
  }
  return millionPortal;
};
const unwrap = (vnode) => {
  if (typeof vnode !== "object" || vnode === null || !("type" in vnode)) {
    if (typeof vnode === "number") {
      return String(vnode);
    }
    return vnode;
  }
  let type = vnode.type;
  if (typeof type === "function") {
    return unwrap(type(vnode.props ?? {}));
  }
  if (typeof type === "object" && "$" in type)
    return type;
  const props = { ...vnode.props };
  if ("css" in props && "__EMOTION_TYPE_PLEASE_DO_NOT_USE__" in props) {
    props.style = props.css.styles;
    type = props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;
    delete props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__;
    delete props.css;
  }
  const children = vnode.props?.children;
  if (children !== void 0 && children !== null) {
    props.children = flatten(vnode.props.children).map(
      (child) => unwrap(child)
    );
  }
  return {
    type,
    // lets pretend no function go through
    props
  };
};
const flatten = (rawChildren) => {
  if (rawChildren === void 0 || rawChildren === null)
    return [];
  if (typeof rawChildren === "object" && "type" in rawChildren && rawChildren.type === react.Fragment) {
    return flatten(rawChildren.props.children);
  }
  if (!Array.isArray(rawChildren) || typeof rawChildren === "object" && "$" in rawChildren) {
    return [rawChildren];
  }
  const flattenedChildren = rawChildren.flat(Infinity);
  const children = [];
  for (let i = 0, l = flattenedChildren.length; i < l; ++i) {
    children.push(...flatten(flattenedChildren[i]));
  }
  return children;
};

const block = (fn, options = {}) => {
  let blockTarget = options?.block;
  const defaultType = options?.svg ? constants.SVG_RENDER_SCOPE : constants.RENDER_SCOPE;
  if (fn) {
    blockTarget = packages_million.block(
      fn,
      unwrap,
      options?.shouldUpdate,
      options?.svg
    );
  }
  const MillionBlock = (props, forwardedRef) => {
    const hmrTimestamp = props._hmr;
    const ref = react.useRef(null);
    const patch = react.useRef(null);
    const portalRef = react.useRef([]);
    props = processProps(props, forwardedRef, portalRef.current);
    patch.current?.(props);
    const effect = react.useCallback(() => {
      if (!ref.current)
        return;
      const currentBlock = blockTarget(props, props.key);
      if (hmrTimestamp && ref.current.textContent) {
        ref.current.textContent = "";
      }
      if (patch.current === null || hmrTimestamp) {
        packages_million.mount$.call(currentBlock, ref.current, null);
        patch.current = (props2) => {
          packages_million.patch(
            currentBlock,
            blockTarget(
              props2,
              props2.key,
              options?.shouldUpdate
            )
          );
        };
      }
    }, []);
    const marker = react.useMemo(() => {
      return react.createElement(options?.as ?? defaultType, { ref });
    }, []);
    const childrenSize = portalRef.current.length;
    const children = new Array(childrenSize);
    for (let i = 0; i < childrenSize; ++i) {
      children[i] = portalRef.current[i]?.portal;
    }
    const vnode = react.createElement(react.Fragment, {}, marker, react.createElement(constants.Effect, {
      effect,
      deps: hmrTimestamp ? [hmrTimestamp] : []
    }), children);
    return vnode;
  };
  if (!packages_million.MapHas$.call(constants.REGISTRY, MillionBlock)) {
    packages_million.MapSet$.call(constants.REGISTRY, MillionBlock, block);
  }
  if (options?.name) {
    if (fn) {
      fn.displayName = `Million(Render(${options.name}))`;
    }
    MillionBlock.displayName = `Million(Block(${options.name}))`;
  }
  return MillionBlock;
};

const MillionArray = ({
  each,
  children,
  memo: memo2,
  svg,
  as,
  ...rest
}) => {
  const ref = react.useRef(null);
  const [portals] = react.useState(() => ({
    current: Array(each.length)
  }));
  const fragmentRef = react.useRef(null);
  const cache = react.useRef({
    each: null,
    children: null,
    mounted: false
  });
  const [, setMountPortals] = react.useState(false);
  if (fragmentRef.current && (each !== cache.current.each || !memo2)) {
    const newChildren = createChildren(each, children, cache, portals, memo2);
    packages_million.arrayPatch$.call(fragmentRef.current, packages_million.mapArray(newChildren));
  }
  const defaultType = svg ? constants.SVG_RENDER_SCOPE : constants.RENDER_SCOPE;
  const MillionFor = react.createElement(
    react.Fragment,
    null,
    react.createElement(as ?? defaultType, { ...rest, ref }),
    ...portals.current.map((p) => p.portal)
  );
  react.useEffect(() => {
    if (!ref.current || fragmentRef.current)
      return;
    if (cache.current.mounted)
      return;
    const newChildren = createChildren(each, children, cache, portals, memo2);
    fragmentRef.current = packages_million.mapArray(newChildren);
    if (!packages_million.MapHas$.call(constants.REGISTRY, MillionFor)) {
      packages_million.MapSet$.call(constants.REGISTRY, MillionFor, fragmentRef.current);
    }
    packages_million.arrayMount$.call(fragmentRef.current, ref.current);
    cache.current.mounted = true;
    setMountPortals(true);
  }, [ref.current]);
  return MillionFor;
};
const typedMemo = react.memo;
const For = typedMemo(MillionArray);
const createChildren = (each, getComponent, cache, portals, memo2) => {
  const children = Array(each.length);
  const currentCache = cache.current;
  for (let i = 0, l = each.length; i < l; ++i) {
    if (memo2 && currentCache.each && currentCache.each[i] === each[i]) {
      children[i] = currentCache.children?.[i];
      continue;
    }
    const vnode = getComponent(each[i], i);
    if (packages_million.MapHas$.call(constants.REGISTRY, vnode.type)) {
      if (!currentCache.block) {
        currentCache.block = packages_million.MapGet$.call(constants.REGISTRY, vnode.type);
      }
      children[i] = currentCache.block(vnode.props, i);
      continue;
    }
    if (typeof vnode.type === "function" && "_c" in vnode.type) {
      const puppetComponent = vnode.type(vnode.props);
      if (packages_million.MapHas$.call(constants.REGISTRY, puppetComponent.type)) {
        const puppetBlock = packages_million.MapGet$.call(constants.REGISTRY, puppetComponent.type);
        if (typeof puppetBlock === "function") {
          children[i] = puppetBlock(puppetComponent.props);
          continue;
        }
      }
    }
    const block = packages_million.block((props) => props?.scope);
    const currentBlock = (props, index) => {
      return block(
        {
          scope: renderReactScope(
            react.createElement(vnode.type, props),
            false,
            portals.current,
            index
          )
        },
        vnode.key ? String(vnode.key) : void 0
      );
    };
    packages_million.MapSet$.call(constants.REGISTRY, vnode.type, currentBlock);
    currentCache.block = currentBlock;
    children[i] = currentBlock(vnode.props, i);
  }
  currentCache.each = each;
  currentCache.children = children;
  return children;
};

function isEqual(a, b) {
  return a === b || a !== a && b !== b;
}
function shouldCompiledBlockUpdate(prev, next) {
  for (const key in prev) {
    if (!isEqual(prev[key], next[key])) {
      return true;
    }
  }
  return false;
}
function compiledBlock(render, { portals, ...options }) {
  const RenderBlock = block((props) => render(props), {
    ...options,
    name: `CompiledBlock(Inner(${options.name}))`,
    shouldUpdate: shouldCompiledBlockUpdate
  });
  const portalCount = portals?.length || 0;
  const Component = portals && portalCount > 0 ? (props) => {
    const [current] = react.useState(() => []);
    const derived = { ...props };
    for (let i = 0; i < portalCount; i++) {
      const index = portals[i];
      derived[index] = renderReactScope(
        derived[index],
        false,
        current,
        i
      );
    }
    const targets = [];
    for (let i = 0, len = current.length; i < len; i++) {
      targets[i] = current[i].portal;
    }
    return react.createElement(
      react.Fragment,
      {},
      react.createElement(RenderBlock, derived),
      targets
    );
  } : (props) => react.createElement(RenderBlock, props);
  if (options.name) {
    Component.displayName = `Million(CompiledBlock(Outer(${options.name})))`;
  }
  return Component;
}

const INTERNALS = {
  block: packages_million.block,
  patch: packages_million.patch,
  mount: packages_million.mount
};
if (typeof window !== "undefined") {
  window.__MILLION_DATA__ = {
    version: "3.0.3"
  };
}

exports.removeComments = packages_million.removeComments;
exports.REGISTRY = constants.REGISTRY;
exports.For = For;
exports.INTERNALS = INTERNALS;
exports.block = block;
exports.compiledBlock = compiledBlock;
exports.renderReactScope = renderReactScope;
exports.unwrap = unwrap;
