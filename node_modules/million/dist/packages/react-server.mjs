'use client';
import { useState, useEffect, createElement, memo, forwardRef, useRef, useCallback, Fragment } from 'react';
import { S as SVG_RENDER_SCOPE, R as RENDER_SCOPE } from '../shared/million.5e1fca0a.mjs';

let globalInfo;
const block = (Component, options = {}) => {
  let blockFactory = globalInfo ? globalInfo.block(Component, options) : null;
  const rscBoundary = options.rsc ? createRSCBoundary(Component, options.svg) : null;
  function MillionBlockLoader(props) {
    const ref = useRef(null);
    const patch = useRef(null);
    const effect = useCallback(() => {
      const init = () => {
        const el = ref.current;
        if (!el)
          return;
        globalInfo.removeComments(el);
        const currentBlock = blockFactory(props, props?.key);
        globalInfo.mount(currentBlock, el, el.firstChild);
        patch.current = (newProps) => {
          globalInfo.patch(currentBlock, blockFactory(newProps, newProps.key));
        };
      };
      if (blockFactory && globalInfo) {
        init();
      } else {
        importSource(() => {
          blockFactory = globalInfo.block(
            Component,
            globalInfo.unwrap,
            options.shouldUpdate,
            options.svg
          );
          init();
        });
      }
      return () => {
        blockFactory = null;
      };
    }, []);
    patch.current?.(props);
    const vnode = createElement(
      Fragment,
      null,
      createElement(Effect, { effect }),
      rscBoundary ? createElement(rscBoundary, { ...props, ref }) : createSSRBoundary(Component, props, ref, options.svg)
    );
    return vnode;
  }
  if (options.name) {
    Component.displayName = `Render(Million(${options.name}))`;
    MillionBlockLoader.displayName = `Block(Million(${options.name}))`;
  }
  return MillionBlockLoader;
};
function For({ each, children, ssr, svg }) {
  const [ready, setReady] = useState(Boolean(globalInfo));
  useEffect(() => {
    if (!globalInfo) {
      importSource(() => {
        setReady(true);
      });
    }
  }, []);
  if (!ready || !globalInfo) {
    if (ssr === false)
      return null;
    return createElement(
      svg ? SVG_RENDER_SCOPE : RENDER_SCOPE,
      { suppressHydrationWarning: true },
      ...each.map(children)
    );
  }
  return createElement(globalInfo.For, {
    each,
    children,
    ssr,
    svg
  });
}
function Effect({ effect }) {
  useEffect(effect, []);
  return null;
}
const importSource = (callback) => {
  void import('./react.mjs').then(({ unwrap, INTERNALS, For: For2, compiledBlock: compiledBlock2, removeComments }) => {
    globalInfo = {
      unwrap,
      For: For2,
      compiledBlock: compiledBlock2,
      removeComments,
      ...INTERNALS
    };
    callback();
  }).catch(() => {
    throw new Error("Failed to load Million.js");
  });
};
const createSSRBoundary = (Component, props, ref, svg = false) => {
  const ssrProps = typeof window === "undefined" ? {
    children: createElement(Component, props)
  } : { dangerouslySetInnerHTML: { __html: "" } };
  return createElement(svg ? SVG_RENDER_SCOPE : RENDER_SCOPE, {
    suppressHydrationWarning: true,
    ref,
    ...ssrProps
  });
};
const createRSCBoundary = (Component, svg = false) => {
  return memo(
    forwardRef(
      (props, ref) => createSSRBoundary(Component, props, ref, svg)
    ),
    () => true
  );
};
function isEqual(a, b) {
  return a === b || a !== a && b !== b;
}
function shouldCompiledBlockUpdate(prev, next) {
  for (const key in prev) {
    if (!isEqual(prev[key], next[key])) {
      return true;
    }
  }
  return false;
}
function compiledBlock(render, { portals, ...options }) {
  const RenderBlock = block((props) => render(props), {
    ...options,
    name: `CompiledBlock(Inner(${options.name}))`,
    shouldUpdate: shouldCompiledBlockUpdate
  });
  const portalCount = portals?.length || 0;
  const Component = portals && portalCount > 0 ? (props) => {
    const [current] = useState(() => []);
    const derived = { ...props };
    const [targets] = useState([]);
    for (let i = 0, len = current.length; i < len; i++) {
      targets[i] = current[i].portal;
    }
    return createElement(
      Fragment,
      {},
      createElement(RenderBlock, derived)
      // TODO: This should be uncommented, but doing that, value.reset would fail as it is undefined. This should be revisited
      // !firstRender ? targets : undefined,
    );
  } : (props) => createElement(RenderBlock, props);
  if (options.name) {
    Component.displayName = `Million(CompiledBlock(Outer(${options.name})))`;
  }
  return Component;
}

export { For, block, compiledBlock, createRSCBoundary, createSSRBoundary, importSource };
