'use client';
'use strict';

const react = require('react');
const constants = require('../shared/million.cdaea7d4.cjs');

let globalInfo;
const block = (Component, options = {}) => {
  let blockFactory = globalInfo ? globalInfo.block(Component, options) : null;
  const rscBoundary = options.rsc ? createRSCBoundary(Component, options.svg) : null;
  function MillionBlockLoader(props) {
    const ref = react.useRef(null);
    const patch = react.useRef(null);
    const effect = react.useCallback(() => {
      const init = () => {
        const el = ref.current;
        if (!el)
          return;
        globalInfo.removeComments(el);
        const currentBlock = blockFactory(props, props?.key);
        globalInfo.mount(currentBlock, el, el.firstChild);
        patch.current = (newProps) => {
          globalInfo.patch(currentBlock, blockFactory(newProps, newProps.key));
        };
      };
      if (blockFactory && globalInfo) {
        init();
      } else {
        importSource(() => {
          blockFactory = globalInfo.block(
            Component,
            globalInfo.unwrap,
            options.shouldUpdate,
            options.svg
          );
          init();
        });
      }
      return () => {
        blockFactory = null;
      };
    }, []);
    patch.current?.(props);
    const vnode = react.createElement(
      react.Fragment,
      null,
      react.createElement(Effect, { effect }),
      rscBoundary ? react.createElement(rscBoundary, { ...props, ref }) : createSSRBoundary(Component, props, ref, options.svg)
    );
    return vnode;
  }
  if (options.name) {
    Component.displayName = `Render(Million(${options.name}))`;
    MillionBlockLoader.displayName = `Block(Million(${options.name}))`;
  }
  return MillionBlockLoader;
};
function For({ each, children, ssr, svg }) {
  const [ready, setReady] = react.useState(Boolean(globalInfo));
  react.useEffect(() => {
    if (!globalInfo) {
      importSource(() => {
        setReady(true);
      });
    }
  }, []);
  if (!ready || !globalInfo) {
    if (ssr === false)
      return null;
    return react.createElement(
      svg ? constants.SVG_RENDER_SCOPE : constants.RENDER_SCOPE,
      { suppressHydrationWarning: true },
      ...each.map(children)
    );
  }
  return react.createElement(globalInfo.For, {
    each,
    children,
    ssr,
    svg
  });
}
function Effect({ effect }) {
  react.useEffect(effect, []);
  return null;
}
const importSource = (callback) => {
  void import('./react.cjs').then(({ unwrap, INTERNALS, For: For2, compiledBlock: compiledBlock2, removeComments }) => {
    globalInfo = {
      unwrap,
      For: For2,
      compiledBlock: compiledBlock2,
      removeComments,
      ...INTERNALS
    };
    callback();
  }).catch(() => {
    throw new Error("Failed to load Million.js");
  });
};
const createSSRBoundary = (Component, props, ref, svg = false) => {
  const ssrProps = typeof window === "undefined" ? {
    children: react.createElement(Component, props)
  } : { dangerouslySetInnerHTML: { __html: "" } };
  return react.createElement(svg ? constants.SVG_RENDER_SCOPE : constants.RENDER_SCOPE, {
    suppressHydrationWarning: true,
    ref,
    ...ssrProps
  });
};
const createRSCBoundary = (Component, svg = false) => {
  return react.memo(
    react.forwardRef(
      (props, ref) => createSSRBoundary(Component, props, ref, svg)
    ),
    () => true
  );
};
function isEqual(a, b) {
  return a === b || a !== a && b !== b;
}
function shouldCompiledBlockUpdate(prev, next) {
  for (const key in prev) {
    if (!isEqual(prev[key], next[key])) {
      return true;
    }
  }
  return false;
}
function compiledBlock(render, { portals, ...options }) {
  const RenderBlock = block((props) => render(props), {
    ...options,
    name: `CompiledBlock(Inner(${options.name}))`,
    shouldUpdate: shouldCompiledBlockUpdate
  });
  const portalCount = portals?.length || 0;
  const Component = portals && portalCount > 0 ? (props) => {
    const [current] = react.useState(() => []);
    const derived = { ...props };
    const [targets] = react.useState([]);
    for (let i = 0, len = current.length; i < len; i++) {
      targets[i] = current[i].portal;
    }
    return react.createElement(
      react.Fragment,
      {},
      react.createElement(RenderBlock, derived)
      // TODO: This should be uncommented, but doing that, value.reset would fail as it is undefined. This should be revisited
      // !firstRender ? targets : undefined,
    );
  } : (props) => react.createElement(RenderBlock, props);
  if (options.name) {
    Component.displayName = `Million(CompiledBlock(Outer(${options.name})))`;
  }
  return Component;
}

exports.For = For;
exports.block = block;
exports.compiledBlock = compiledBlock;
exports.createRSCBoundary = createRSCBoundary;
exports.createSSRBoundary = createSSRBoundary;
exports.importSource = importSource;
